#!/bin/bash
#set -x
# Copyright (C) 2022 by Jonathan Appavoo, Boston University
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# Services information
# --------------------

# REPO Services
REPO_CMD="git"
INIT="init"
REMOTE_ADD="remote add"
CHECK_REMOTES="remote -v"
CLONE="clone"
PULL="pull"
PUSH="push"
PUSH_FIRST="push -f -u"
SWITCH_BRANCH="checkout"
CREATE_BRANCH="checkout -b"
IGNORE_FILE=".gitignore"
RENAME_BRANCH="branch -m"
FETCH="fetch"
ADD="add"
COMMIT="commit -m"
CURRENT_BRANCH="branch --show-current"
REBASE="rebase"
REPO_URL="git@github.com:\${ORG_NAME}/\${REPO_NAME}.git"
REPO_SERVICE_DIR=".git"
IF_INSIDE_REPO="rev-parse --is-inside-work-tree"
SHOW_TOP_LEVEL="rev-parse --show-toplevel"


# email services
EMAIL_SERVICE="gmail"

# OPE INFORMATION
# --------------------
OPE_ORG_NAME="OPEFFORT"
OPE_REPO_NAME="ope"
OPE_CONFIG_DIR="opeconfig"
UPSTREAM_BRANCHES=("main" "coursecontenttemplate" "Documentation")

# --------- Script begins here -------------

# Script Configuration
HEADER="[OPE] "
VERBOSE=0
LOG_FILE="/tmp/ope.log"

# Color Configuration
Color_Off='\033[0m'       # Text Reset
Black='\033[0;30m'        # Black
Red='\033[0;31m'          # Red
Green='\033[0;32m'        # Green
Yellow='\033[0;33m'       # Yellow
Blue='\033[0;34m'         # Blue
Purple='\033[0;35m'       # Purple
Cyan='\033[0;36m'         # Cyan
White='\033[0;37m'        # White
Grey='\033[0;37m'         # Grey
BBlack='\033[1;30m'       # Bold Black
BCyan='\033[1;36m'        # Bold Cyan
BGreen='\033[1;32m'

# Helper functions
fc_header_logging (){
    current_time=$(date +%T)
    cwd=$(pwd)
    echo "[${current_time}]: ${0##*/} $1 $cwd" >> $LOG_FILE
}

rolling_output () {
    input=$(cat <&0 | tr '\r' '\n')
    if [[ $VERBOSE -eq 0 ]]; then
        echo $input | while read line; do echo -ne "\033[2K\r"; printf "     ${Grey}$line${Color_Off}\r"; done
    else
        cat <&0
    fi
}

verify_repo (){

    # Check if we are inside a repository
    if ! ${REPO_CMD} ${IF_INSIDE_REPO} &>/dev/null; then
        echo -e "$HEADER${Red}ERROR: Not a valid repository${Color_Off}"
        return -1
    fi

    # Check if we are inside an OPE repository
    output=$(${REPO_CMD} ${CHECK_REMOTES})
    if ! echo "$output" | grep -q "ope-upstream"; then
        echo -e "$HEADER${Red}ERROR: Not a valid OPE repository${Color_Off}"
        return -1
    fi

    # Check if we are inside the top level of the OPE repository
    if [ "$(pwd)" != "$(${REPO_CMD} ${SHOW_TOP_LEVEL})" ]; then
        cd "$(${REPO_CMD} ${SHOW_TOP_LEVEL})"
    fi
    
}

get_help_from_makefile(){
    option=$1
    cat Makefile | grep -E '^[a-zA-Z0-9_%/-]+:.*?## .*$$' | grep -E "^${option}" | tr -d '#' |column -t -s : | tr '-' ' '
}

function clone
#DESCRIPTION: clone the OPE repository for development
{
    url=$1

    # Help message
    if [[ -z $url || $url = '-h' ]]; then
        echo "Usage:  ${0##*/} clone <url>"
        echo "   will clone the OPE repository and setup the branches for development"
        echo "   See the ope gettings started doc for more info."
        return -1
    fi

    basename=$(basename $url)
    repo=${basename%.*}

    # Check if the organization already exists locally
    if [[ -d $repo ]]; then
        echo -e "$HEADER${Red}ERROR: Repository $repo already exists${Color_Off}"
        return -1
    fi

    ORG_NAME="${OPE_ORG_NAME}"
    REPO_NAME="${OPE_REPO_NAME}"
    eval "OPE_REPO_URL=$REPO_URL"
    echo $OPE_REPO_URL

    echo -e "$HEADER${Cyan}Creating OPE repository locally${Color_Off}"
    mkdir -p ${repo}
    cd ${repo}
    echo -e "$HEADER${Cyan}Linking ope-upstream branches${Color_Off}"

    ${REPO_CMD} ${INIT}
    # Adding the remotes
    ${REPO_CMD} ${REMOTE_ADD} ope-upstream ${OPE_REPO_URL} # | rolling_output #0<&0
    ${REPO_CMD} ${REMOTE_ADD} origin ${url} # | rolling_output #0<&0

    for branch in "${UPSTREAM_BRANCHES[@]}"; do
        ${REPO_CMD} ${FETCH} ope-upstream ${branch} 2>&1  # | rolling_output #0<&0 #| while read line; do echo -ne "\033[2K\r"; printf "    ${Grey}$line${Color_Off}\r"; done 
        ${REPO_CMD} ${FETCH} origin ${branch} 2>&1  # | rolling_output #0<&0 #| while read line; do echo -ne "\033[2K\r"; printf "    ${Grey}$line${Color_Off}\r"; done 
        ${REPO_CMD} ${CREATE_BRANCH} ${branch} origin/${branch} 2>&1  # | rolling_output #0<&0 #| while read line; do echo -ne "\033[2K\r"; printf "    ${Grey}$line${Color_Off}\r"; done
        ${REPO_CMD} ${CREATE_BRANCH} ${branch}-source ope-upstream/${branch} 2>&1  # | rolling_output #0<&0 #| while read line; do echo -ne "\033[2K\r"; printf "    ${Grey}$line${Color_Off}\r"; done    
    done

    ${REPO_CMD} ${SWITCH_BRANCH} ${UPSTREAM_BRANCHES[0]}  2>&1

}

function create
#DESCRIPTION: create a new book organization from the ope template
{   
    name=$1
    
    # Logging information
    func_name=${FUNCNAME[0]}
    func_args=$@
    fc_header_logging "$func_name $func_args"

    # Help message
    if [[ -z $name || $name == '-h' ]]; then
        echo "Usage:  ${0##*/} create <bookName>"
        echo "   create an organization using ope template of the name specified"
        echo "   eg. ope create MyBook"
        echo "   will create a new local repository seeded from the ope "
        echo "   template.  See the ope gettings started doc for more info."
        return -1
    fi

    {
        # Check if the organization already exists locally
        if [[ -d $name ]]; then
            echo -e "$HEADER${Red}ERROR: Organization/Directory already exists${Color_Off}"
            return -1
        fi

        # Create the organization
        mkdir -p $name
        # Creating configuration
        echo -e "$HEADER${Cyan}Creating OPE configurations${Color_Off}"
        #touch $IGNORE_FILE
        #echo $OPE_CONFIG_DIR >> $IGNORE_FILE
        #mkdir -p $OPE_CONFIG_DIR

        cd $name
        
        read -r -p "    Enter the email of the ${name} orginzation: " user_input
        if [ -z "$user_input" ]; then
            #echo "${name}@${EMAIL_SERVICE}.com" > ../$OPE_CONFIG_DIR/email
            echo -e "    The email was set to default value: ${BBlack}${name}@${EMAIL_SERVICE}.com${Color_Off}"
        else
            #echo $user_input > ../$OPE_CONFIG_DIR/email
            echo -e "    The email was set to: ${BBlack}${user_input}${Color_Off}"
        fi


        read -r -p "    Enter the source URL of the ${name} orginzation: " user_input
        if [ -z "$user_input" ]; then
            ORG_NAME="${name}"
            REPO_NAME="${name}"
            eval "NEW_REPO_URL=$REPO_URL"
        else
            NEW_REPO_URL=$user_input  
        fi
        #echo $NEW_REPO_URL > ../$OPE_CONFIG_DIR/source_url
        echo -e "    The ${name} source URL was set to: ${BBlack}${NEW_REPO_URL}${Color_Off}"

        # Creating the organization
        while true; do
            read -r -p "    Are you building on top of an existing OPE book? [Y/n]: " user_input
            if [ -z "$user_input" ]; then
                user_input="n"
                break;
            elif [ "$user_input" == "n" ]; then
                break;
            elif [ "$user_input" == "Y" ]; then
                break;
            else
                echo -e "    ${Red}ERROR: Invalid input. Please enter Y/n ${Color_Off}"
            fi
        done

        if [ "$user_input" == "n" ]; then
            echo -e "$HEADER${Cyan}Seeding from OPE content template${Color_Off}"
            ${REPO_CMD} ${INIT} 
            ORG_NAME="${OPE_ORG_NAME}"
            REPO_NAME="${OPE_REPO_NAME}"
            eval "OPE_REPO_URL=$REPO_URL"
        else
            echo -e "$HEADER${Cyan}Seeding from existing book content template${Color_Off}"
            while true; do
                read -r -p "    Enter the OPE source URL of the existing book: " user_input
                if [ -z "$user_input" ]; then
                    echo -e "    ${Red}ERROR: Invalid input. Please try again${Color_Off}"
                else
                    break;
                fi
            done
            # | rolling_output
            OPE_REPO_URL=$user_input
        fi

        ${REPO_CMD} ${INIT}

        # Adding the remotes
        ${REPO_CMD} ${REMOTE_ADD} ope-upstream ${OPE_REPO_URL} # | rolling_output #0<&0
        ${REPO_CMD} ${REMOTE_ADD} origin ${NEW_REPO_URL} # | rolling_output #0<&0

        for branch in "${UPSTREAM_BRANCHES[@]}"; do
            ${REPO_CMD} ${FETCH} ope-upstream ${branch} 2>&1  # | rolling_output #0<&0 #| while read line; do echo -ne "\033[2K\r"; printf "    ${Grey}$line${Color_Off}\r"; done 
            ${REPO_CMD} ${SWITCH_BRANCH} ${branch}  2>&1  # | rolling_output #0<&0 #| while read line; do echo -ne "\033[2K\r"; printf "    ${Grey}$line${Color_Off}\r"; done
            ${REPO_CMD} ${RENAME_BRANCH} ${branch}-source  2>&1  # | rolling_output #0<&0 #| while read line; do echo -ne "\033[2K\r"; printf "    ${Grey}$line${Color_Off}\r"; done
            ${REPO_CMD} ${CREATE_BRANCH} ${branch}  2>&1  # | rolling_output #0<&0 #| while read line; do echo -ne "\033[2K\r"; printf "    ${Grey}$line${Color_Off}\r"; done
            ${REPO_CMD} ${PUSH_FIRST} origin ${branch} 2>&1 # | rolling_output #0<&0
        done

        ${REPO_CMD} ${SWITCH_BRANCH} ${UPSTREAM_BRANCHES[0]}  2>&1  # # | rolling_output
        echo -ne "\033[2K\r"
        #printf "$HEADER${Cyan}Initilal Commit to ${name} repository.${Color_Off}\n"
        #mv ../$IGNORE_FILE .
        #mv ../$OPE_CONFIG_DIR .
        #${REPO_CMD} ${ADD} . #2>&1 # | rolling_output
        #${REPO_CMD} ${COMMIT} "Initial commit from the ope command line tool" 2>&1 ## | rolling_output
        #${REPO_CMD} ${PUSH} 2>&1 ## | rolling_output
        echo -e "$HEADER${Green}OPE book organization has been successfully created ${Color_Off}"

    } 2>&1 | tee >(sed "s/$(printf '\033')\[[0-9;]*[a-zA-Z]//g" >> $LOG_FILE) 
}

function update
#DESCRIPTION: update and rebase changes from the OPE framework
{
    option=$1
    verify_repo

    if [[ ! -z "$option" && $option = '-h' ]]; then
        echo "Usage:  ${0##*/} update [options]"
        echo "   will update and rebase based on the current branch"
        echo "   options:"
        echo "       -u: update the OPE framework only and do not perform a rebase"
        echo "   See the ope gettings started doc for more info."
        return -1
    fi

    current_branch=$(${REPO_CMD} ${CURRENT_BRANCH})
    echo -e "$HEADER${Cyan}Updating the book repository on ${Color_Off}${BCyan}${current_branch}${Color_Off}"
    ${REPO_CMD} ${SWITCH_BRANCH} ${current_branch}-source
    ${REPO_CMD} ${PULL} ope-upstream ${current_branch}
    ${REPO_CMD} ${SWITCH_BRANCH} ${current_branch}

    if [[ $option = '-u' ]]; then
        echo -e "$HEADER${Cyan}Updating the OPE framework only${Color_Off}"
        echo -e "$HEADER${BGreen}OPE upstream ${current_branch}${Color_Off}${Green} has been successfully updated ${Color_Off}"
        return
    fi

    echo -e "$HEADER${Cyan}Rebasing the book repository on ${Color_Off}${BCyan}${current_branch}${Color_Off}"
    ${REPO_CMD} ${REBASE} ${current_branch}-source
    echo -e "$HEADER${BGreen}${current_branch}${Color_Off}${Green} has been successfully updated ${Color_Off}"


}

function build
#DESCRIPTION: build the book
{
    option=$1
    verify_repo

    if [[ $option = '-h' ]]; then
        echo "Usage:  ${0##*/} build [options]"
        echo
        echo "   will build based on the current branch"
        echo
        get_help_from_makefile build
        echo "   See the ope gettings started doc for more info."
        return -1
    fi

    if [[ ! -z "$option" ]]; then
        option="-${option}"
        echo $option
    fi

    # Logging information
    func_name=${FUNCNAME[0]}
    func_args=$@
    fc_header_logging "$func_name $func_args"

    {
        current_branch=$(${REPO_CMD} ${CURRENT_BRANCH})
        echo -e "$HEADER${Cyan}Building the on ${Color_Off}${BCyan}${current_branch}${Color_Off}"
        make build${option}
        echo -e "$HEADER${Green}${current_branch} has been successfully built ${Color_Off}"
    } 2>&1 | tee >(sed "s/$(printf '\033')\[[0-9;]*[a-zA-Z]//g" >> $LOG_FILE)

}

function pub
#DESCRIPTION: publish the book
{   
    option=$1
    verify_repo

    if [[ $option = '-h' ]]; then
        echo "Usage:  ${0##*/} pub [options]"
        echo
        echo "   will publish the materials based on the current branch"
        echo
        get_help_from_makefile pub
        echo "   See the ope gettings started doc for more info."
        return -1
    fi

    if [[ ! -z "$option" ]]; then
        option="-${option}"
        echo $option
    fi

    current_branch=$(${REPO_CMD} ${CURRENT_BRANCH})
    echo -e "$HEADER${Cyan}Publishing the on ${Color_Off}${BCyan}${current_branch}${Color_Off}"
    make pub
    echo -e "$HEADER${Green}${current_branch} has been successfully published ${Color_Off}"
}

print_func_page()
{
    func_names=($(grep '^function' $0 | awk '{print $2}'))
    grep '^#DESCRIPTION' $0 | awk -F: '{print $2}' | while read line ; do echo -e "  ${Blue}${func_names[$i]}${Color_Off}, $line\n"; i=$((i+1)); done | column -t -s,
}

Usage()
{
    echo 
    echo "Usage:  ${0##*/} FUNCTION {ARGS} " >&2
    echo
    echo "A command-line tool for building open source infrastructures using ope framework"
    echo 
    echo "Functions: "
    print_func_page
    echo
    echo "for each func use '-h' to print its Usage: eg. ${0##*/} dump -h"
    echo "will print the Usage for the dump command"
}




process_args()
{
  if [[ $# == 0 || $1 = '-h' ]]
  then
    Usage
    exit -1
  fi

  dofunc=$1
}

set -e
set -o pipefail

process_args "$@"
shift

$dofunc "$@"

exit $?
